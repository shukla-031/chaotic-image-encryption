import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
from PIL import Image, ImageTk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import os
import time

class ImageDecryptionApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Advanced Image Decryption System")
        self.root.geometry("1200x800")
        self.root.configure(bg='#f0f0f0')
        
        # Style configuration
        self.style = ttk.Style()
        self.style.configure('TButton', font=('Arial', 10), padding=5)
        self.style.configure('TLabel', font=('Arial', 10))
        self.style.configure('Header.TLabel', font=('Arial', 12, 'bold'))
        
        # Variables
        self.encrypted_img = None
        self.decrypted_img = None
        self.decryption_time = None
        
        # Create GUI
        self.create_widgets()
        
    def create_widgets(self):
        # Main container
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        title_label = ttk.Label(main_frame, text="Advanced Image Decryption System", 
                               style='Header.TLabel', font=('Arial', 16, 'bold'))
        title_label.pack(pady=(0, 15))
        
        # Control Frame
        control_frame = ttk.Frame(main_frame)
        control_frame.pack(fill=tk.X, pady=10)
        
        # Load Encrypted Button
        self.load_btn = ttk.Button(control_frame, text="Load Encrypted Image", 
                                command=self.load_encrypted_image)
        self.load_btn.pack(side=tk.LEFT, padx=5)
        
        # Decrypt Button
        self.decrypt_btn = ttk.Button(control_frame, text="Decrypt Image", 
                                   command=self.decrypt_image, state=tk.DISABLED)
        self.decrypt_btn.pack(side=tk.LEFT, padx=5)
        
        # Save Decrypted Button
        self.save_dec_btn = ttk.Button(control_frame, text="Save Decrypted", 
                                command=lambda: self.save_image(self.decrypted_img), state=tk.DISABLED)
        self.save_dec_btn.pack(side=tk.LEFT, padx=5)
        
        # Analysis Button
        self.analysis_btn = ttk.Button(control_frame, text="Decryption Analysis", 
                                command=self.decryption_analysis, state=tk.DISABLED)
        self.analysis_btn.pack(side=tk.LEFT, padx=5)
        
        # Content Frame
        content_frame = ttk.Frame(main_frame)
        content_frame.pack(fill=tk.BOTH, expand=True)
        
        # Left Panel - Parameters and Info
        left_panel = ttk.Frame(content_frame, width=300)
        left_panel.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))
        left_panel.pack_propagate(False)
        
        # Parameters Frame
        param_frame = ttk.LabelFrame(left_panel, text="Decryption Parameters", padding=10)
        param_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Arnold Parameters
        ttk.Label(param_frame, text="Arnold Iterations:").grid(row=0, column=0, sticky='w', pady=2)
        self.arnold_iters = ttk.Entry(param_frame, width=10)
        self.arnold_iters.insert(0, "2")
        self.arnold_iters.grid(row=0, column=1, sticky='w', pady=2)
        
        # Logistic Map Parameters
        ttk.Label(param_frame, text="Logistic r:").grid(row=1, column=0, sticky='w', pady=2)
        self.logistic_r = ttk.Entry(param_frame, width=10)
        self.logistic_r.insert(0, "3.9999")
        self.logistic_r.grid(row=1, column=1, sticky='w', pady=2)
        
        ttk.Label(param_frame, text="Logistic x0:").grid(row=2, column=0, sticky='w', pady=2)
        self.logistic_x0 = ttk.Entry(param_frame, width=10)
        self.logistic_x0.insert(0, "0.5123")
        self.logistic_x0.grid(row=2, column=1, sticky='w', pady=2)
        
        # Tent Map Parameters
        ttk.Label(param_frame, text="Tent Î¼:").grid(row=3, column=0, sticky='w', pady=2)
        self.tent_mu = ttk.Entry(param_frame, width=10)
        self.tent_mu.insert(0, "1.9999")
        self.tent_mu.grid(row=3, column=1, sticky='w', pady=2)
        
        ttk.Label(param_frame, text="Tent x0:").grid(row=4, column=0, sticky='w', pady=2)
        self.tent_x0 = ttk.Entry(param_frame, width=10)
        self.tent_x0.insert(0, "0.4567")
        self.tent_x0.grid(row=4, column=1, sticky='w', pady=2)
        
        # Chebyshev Map Parameters
        ttk.Label(param_frame, text="Chebyshev k:").grid(row=5, column=0, sticky='w', pady=2)
        self.chebyshev_k = ttk.Entry(param_frame, width=10)
        self.chebyshev_k.insert(0, "4")
        self.chebyshev_k.grid(row=5, column=1, sticky='w', pady=2)
        
        ttk.Label(param_frame, text="Chebyshev x0:").grid(row=6, column=0, sticky='w', pady=2)
        self.chebyshev_x0 = ttk.Entry(param_frame, width=10)
        self.chebyshev_x0.insert(0, "0.2345")
        self.chebyshev_x0.grid(row=6, column=1, sticky='w', pady=2)
        
        # Decryption Rounds
        ttk.Label(param_frame, text="Decryption Rounds:").grid(row=7, column=0, sticky='w', pady=2)
        self.dec_rounds = ttk.Entry(param_frame, width=10)
        self.dec_rounds.insert(0, "2")
        self.dec_rounds.grid(row=7, column=1, sticky='w', pady=2)
        
        # Decryption Key
        ttk.Label(param_frame, text="Decryption Key:").grid(row=8, column=0, sticky='w', pady=2)
        self.dec_key = ttk.Entry(param_frame, width=10)
        self.dec_key.insert(0, "high_uaci_fast")
        self.dec_key.grid(row=8, column=1, sticky='w', pady=2)
        
        # Info Frame
        info_frame = ttk.LabelFrame(left_panel, text="Image Information", padding=10)
        info_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.img_info_text = tk.Text(info_frame, height=8, width=30, font=('Arial', 9))
        self.img_info_text.pack(fill=tk.BOTH, expand=True)
        self.img_info_text.insert(tk.END, "No image loaded")
        self.img_info_text.config(state=tk.DISABLED)
        
        # Entropy Frame
        entropy_frame = ttk.LabelFrame(left_panel, text="Entropy Analysis", padding=10)
        entropy_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.encrypted_entropy = tk.StringVar()
        self.encrypted_entropy.set("Encrypted: -")
        ttk.Label(entropy_frame, textvariable=self.encrypted_entropy).pack(anchor='w')
        
        self.decrypted_entropy = tk.StringVar()
        self.decrypted_entropy.set("Decrypted: -")
        ttk.Label(entropy_frame, textvariable=self.decrypted_entropy).pack(anchor='w')
        
        # Performance Frame
        time_frame = ttk.LabelFrame(left_panel, text="Performance", padding=10)
        time_frame.pack(fill=tk.X)
        
        self.decryption_time_var = tk.StringVar()
        self.decryption_time_var.set("Decryption Time: -")
        ttk.Label(time_frame, textvariable=self.decryption_time_var).pack(anchor='w')
        
        # Right Panel - Image Display
        right_panel = ttk.Frame(content_frame)
        right_panel.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)
        
        # Image Display Frame
        img_frame = ttk.Frame(right_panel)
        img_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # Encrypted Image
        encrypted_frame = ttk.LabelFrame(img_frame, text="Encrypted Image", padding=5)
        encrypted_frame.grid(row=0, column=0, padx=5, pady=5, sticky='nsew')
        self.encrypted_canvas = tk.Canvas(encrypted_frame, width=350, height=350, bg='gray')
        self.encrypted_canvas.pack(fill=tk.BOTH, expand=True)
        
        # Decrypted Image
        decrypted_frame = ttk.LabelFrame(img_frame, text="Decrypted Image", padding=5)
        decrypted_frame.grid(row=0, column=1, padx=5, pady=5, sticky='nsew')
        self.decrypted_canvas = tk.Canvas(decrypted_frame, width=350, height=350, bg='gray')
        self.decrypted_canvas.pack(fill=tk.BOTH, expand=True)
        
        # Configure grid weights
        img_frame.columnconfigure(0, weight=1)
        img_frame.columnconfigure(1, weight=1)
        img_frame.rowconfigure(0, weight=1)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.pack(fill=tk.X, pady=5)
        
        # Status bar
        self.status_var = tk.StringVar()
        self.status_var.set("Ready to decrypt images")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, relief=tk.SUNKEN)
        status_bar.pack(fill=tk.X, side=tk.BOTTOM)
    
    def update_status(self, message):
        self.status_var.set(message)
        self.root.update_idletasks()
    
    def load_encrypted_image(self):
        file_path = filedialog.askopenfilename(filetypes=[
            ("Image files", "*.tif;*.tiff;*.png;*.jpg;*.jpeg;*.bmp")
        ])
        if file_path:
            try:
                self.update_status("Loading encrypted image...")
                # Read image using PIL
                img = Image.open(file_path).convert('L')  # Convert to grayscale
                self.encrypted_img = np.array(img)
                
                # Display image
                self.display_image(self.encrypted_img, self.encrypted_canvas)
                
                # Update image info
                self.update_image_info(file_path)
                
                # Calculate and display entropy
                entropy = self.calculate_entropy(self.encrypted_img)
                self.encrypted_entropy.set(f"Encrypted: {entropy:.6f}")
                self.decrypted_entropy.set("Decrypted: -")
                self.decryption_time_var.set("Decryption Time: -")
                
                # Clear decrypted canvas
                self.clear_canvas(self.decrypted_canvas)
                
                # Enable buttons
                self.decrypt_btn.config(state=tk.NORMAL)
                self.save_dec_btn.config(state=tk.DISABLED)
                self.analysis_btn.config(state=tk.DISABLED)
                
                self.update_status("Encrypted image loaded successfully")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load encrypted image: {str(e)}")
                self.update_status("Error loading encrypted image")
    
    def update_image_info(self, file_path):
        self.img_info_text.config(state=tk.NORMAL)
        self.img_info_text.delete(1.0, tk.END)
        
        file_name = os.path.basename(file_path)
        file_size = os.path.getsize(file_path) / 1024  # KB
        img_shape = self.encrypted_img.shape
        
        info_text = f"File: {file_name}\n"
        info_text += f"Size: {file_size:.2f} KB\n"
        info_text += f"Dimensions: {img_shape[1]} x {img_shape[0]}\n"
        info_text += f"Format: {self.encrypted_img.dtype}\n"
        info_text += f"Min value: {self.encrypted_img.min()}\n"
        info_text += f"Max value: {self.encrypted_img.max()}\n"
        info_text += f"Mean: {self.encrypted_img.mean():.2f}\n"
        info_text += f"Std: {self.encrypted_img.std():.2f}"
        
        self.img_info_text.insert(tk.END, info_text)
        self.img_info_text.config(state=tk.DISABLED)
    
    def clear_canvas(self, canvas):
        canvas.delete("all")
        canvas.create_text(175, 175, text="No Image", fill="white", font=('Arial', 12))
    
    def display_image(self, img_array, canvas):
        img_pil = Image.fromarray(img_array)
        # Calculate aspect ratio preserving dimensions
        canvas_width = canvas.winfo_width()
        canvas_height = canvas.winfo_height()
        
        if canvas_width <= 1 or canvas_height <= 1:  # Canvas not yet rendered
            canvas_width, canvas_height = 350, 350
            
        img_ratio = img_pil.width / img_pil.height
        canvas_ratio = canvas_width / canvas_height
        
        if img_ratio > canvas_ratio:
            new_width = canvas_width
            new_height = int(canvas_width / img_ratio)
        else:
            new_height = canvas_height
            new_width = int(canvas_height * img_ratio)
            
        img_pil = img_pil.resize((new_width, new_height), Image.Resampling.LANCZOS)
        img_tk = ImageTk.PhotoImage(img_pil)
        
        canvas.image = img_tk  # Keep reference
        canvas.delete("all")
        canvas.create_image(canvas_width//2, canvas_height//2, anchor=tk.CENTER, image=img_tk)
    
    def calculate_entropy(self, img):
        """Calculate Shannon entropy of an image"""
        hist, _ = np.histogram(img.flatten(), bins=256, range=(0, 256))
        hist = hist[hist > 0] / hist.sum()  # Normalize and remove zeros
        return -np.sum(hist * np.log2(hist))
    
    def decrypt_image(self):
        if self.encrypted_img is None:
            return
            
        try:
            self.progress.start()
            self.update_status("Decrypting image...")
            
            # Start timing
            start_time = time.time()
            
            # Get decryption parameters
            arnold_iters = int(self.arnold_iters.get())
            logistic_r = float(self.logistic_r.get())
            logistic_x0 = float(self.logistic_x0.get())
            tent_mu = float(self.tent_mu.get())
            tent_x0 = float(self.tent_x0.get())
            chebyshev_k = int(self.chebyshev_k.get())
            chebyshev_x0 = float(self.chebyshev_x0.get())
            dec_rounds = int(self.dec_rounds.get())
            dec_key = self.dec_key.get()
            
            # Start with encrypted image
            decrypted = self.encrypted_img.copy().astype(np.int32)
            h, w = decrypted.shape
            
            # Generate sequences for decryption (same as encryption but in reverse)
            tent_sequences = []
            chebyshev_sequences = []
            
            # First generate all sequences in forward order
            for round_num in range(dec_rounds):
                total_pixels = h * w
                
                # Use key with round-specific modification
                round_key = dec_key + str(round_num)
                key_hash = sum(ord(c) for c in round_key) % 10000
                np.random.seed(key_hash)
                
                # Generate sequences
                tent_seq = self.generate_tent_sequence(tent_mu, tent_x0 + round_num * 0.001, total_pixels)
                chebyshev_seq = self.generate_chebyshev_sequence(chebyshev_k, chebyshev_x0 + round_num * 0.001, total_pixels)
                
                # Safe normalization
                tent_seq = self.safe_normalization(tent_seq)
                chebyshev_seq = self.safe_normalization(chebyshev_seq)
                
                # Reshape sequences
                tent_seq = tent_seq.reshape((h, w)).astype(np.int32)
                chebyshev_seq = chebyshev_seq.reshape((h, w)).astype(np.int32)
                
                tent_sequences.append(tent_seq)
                chebyshev_sequences.append(chebyshev_seq)
            
            # Reverse the decryption process
            for round_num in reversed(range(dec_rounds)):
                self.update_status(f"Decryption round {dec_rounds - round_num}/{dec_rounds}...")
                
                # Get the sequences (in reverse order)
                tent_seq = tent_sequences[round_num]
                chebyshev_seq = chebyshev_sequences[round_num]
                
                # Reverse Operation 4: Safe conditional operations (self-inverse)
                decrypted = self.safe_conditional_operations(decrypted, tent_seq)
                
                # Reverse Operation 3: Bit rotation (rotate in opposite direction)
                reverse_bits = (8 - ((round_num * 3 + 1) % 8)) % 8
                decrypted = self.safe_bit_rotation(decrypted, reverse_bits)
                
                # Reverse Operation 2: Safe modular operations
                decrypted = self.safe_modular_decryption(decrypted, chebyshev_seq)
                
                # Reverse Operation 1: XOR (self-inverse)
                decrypted = self.safe_xor_operation(decrypted, tent_seq)
                
                # Reverse Arnold transform (only in first round)
                if round_num == 0:
                    decrypted = self.inverse_arnold_transform_safe(decrypted.astype(np.uint8), iterations=arnold_iters)
                    decrypted = decrypted.astype(np.int32)
            
            # Final safe conversion to uint8
            self.decrypted_img = self.safe_final_conversion(decrypted)
            
            # Calculate decryption time
            end_time = time.time()
            self.decryption_time = end_time - start_time
            
            # Display decrypted image
            self.display_image(self.decrypted_img, self.decrypted_canvas)
            
            # Calculate and display entropy
            entropy = self.calculate_entropy(self.decrypted_img)
            self.decrypted_entropy.set(f"Decrypted: {entropy:.6f}")
            
            # Display decryption time
            self.decryption_time_var.set(f"Decryption Time: {self.decryption_time:.3f} seconds")
            
            # Enable buttons
            self.save_dec_btn.config(state=tk.NORMAL)
            self.analysis_btn.config(state=tk.NORMAL)
            
            self.progress.stop()
            self.update_status(f"Decryption completed in {self.decryption_time:.3f} seconds")
            
        except Exception as e:
            self.progress.stop()
            messagebox.showerror("Error", f"Decryption failed: {str(e)}")
            self.update_status("Decryption failed")
    
    def safe_modular_decryption(self, img, seq):
        """Reverse modular operations for decryption"""
        img_uint8 = img.astype(np.uint8)
        seq_uint8 = seq.astype(np.uint8)
        
        # Reverse the addition with modulo
        result = img_uint8.astype(np.int32) - seq_uint8.astype(np.int32)
        result = result % 256
        # Ensure positive values
        result[result < 0] += 256
        
        return result
    
    def inverse_arnold_transform_safe(self, img, iterations=1):
        """Inverse Arnold transform"""
        h, w = img.shape
        transformed = np.zeros_like(img)
        
        for _ in range(iterations):
            for y in range(h):
                for x in range(w):
                    # Inverse Arnold transform formula
                    new_x = (x - y) % w
                    new_y = (2*y - x) % h
                    # Ensure indices are positive
                    new_x = new_x if new_x >= 0 else new_x + w
                    new_y = new_y if new_y >= 0 else new_y + h
                    transformed[new_y, new_x] = img[y, x]
            img = transformed.copy()
            
        return img
    
    def generate_tent_sequence(self, mu, x0, length):
        """Generate tent map sequence"""
        seq = np.zeros(length)
        seq[0] = x0
        
        # Skip transient
        for i in range(100):
            if seq[0] < 0.5:
                seq[0] = mu * seq[0]
            else:
                seq[0] = mu * (1 - seq[0])
        
        for i in range(1, length):
            if seq[i-1] < 0.5:
                seq[i] = mu * seq[i-1]
            else:
                seq[i] = mu * (1 - seq[i-1])
        
        return seq
    
    def generate_chebyshev_sequence(self, k, x0, length):
        """Generate Chebyshev polynomial sequence"""
        seq = np.zeros(length)
        seq[0] = x0
        
        # Skip transient
        for i in range(100):
            seq[0] = np.cos(k * np.arccos(seq[0]))
        
        for i in range(1, length):
            seq[i] = np.cos(k * np.arccos(seq[i-1]))
        
        return seq
    
    def safe_normalization(self, seq):
        """Safe normalization without overflow"""
        # Simple min-max normalization
        seq_min = seq.min()
        seq_max = seq.max()
        
        if seq_max - seq_min > 1e-10:
            seq_normalized = (seq - seq_min) / (seq_max - seq_min)
        else:
            seq_normalized = seq - seq_min
            
        return (seq_normalized * 255).astype(np.uint8)
    
    def safe_xor_operation(self, img, seq):
        """Safe XOR operation"""
        img_uint8 = img.astype(np.uint8)
        seq_uint8 = seq.astype(np.uint8)
        
        result = np.bitwise_xor(img_uint8, seq_uint8)
        return result.astype(np.int32)
    
    def safe_bit_rotation(self, img, bits):
        """Safe bit rotation"""
        if bits == 0:
            return img
            
        img_uint8 = img.astype(np.uint8)
        rotated = ((img_uint8 << bits) | (img_uint8 >> (8 - bits))) & 0xFF
        return rotated.astype(np.int32)
    
    def safe_conditional_operations(self, img, control_seq):
        """Safe conditional operations"""
        img_uint8 = img.astype(np.uint8)
        control_uint8 = control_seq.astype(np.uint8)
        
        # Simple conditional inversion (self-inverse operation)
        mask = control_uint8 > 128
        result = img_uint8.copy()
        result[mask] = 255 - result[mask]
        
        return result.astype(np.int32)
    
    def safe_final_conversion(self, img):
        """Safe final conversion to uint8"""
        # Ensure all values are in 0-255 range
        img_clipped = np.clip(img, 0, 255)
        return img_clipped.astype(np.uint8)
    
    def save_image(self, img):
        if img is not None:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG files", "*.png"), ("TIFF files", "*.tif;*.tiff"), 
                          ("JPEG files", "*.jpg;*.jpeg"), ("BMP files", "*.bmp")]
            )
            if file_path:
                try:
                    Image.fromarray(img).save(file_path)
                    messagebox.showinfo("Success", "Image saved successfully!")
                    self.update_status("Image saved successfully")
                except Exception as e:
                    messagebox.showerror("Error", f"Failed to save image: {str(e)}")
                    self.update_status("Error saving image")
    
    def decryption_analysis(self):
        if self.encrypted_img is None or self.decrypted_img is None:
            messagebox.showwarning("Warning", "Please decrypt an image first")
            return
        
        try:
            self.update_status("Performing decryption analysis...")
            
            # Create analysis window
            analysis_window = tk.Toplevel(self.root)
            analysis_window.title("Decryption Analysis")
            analysis_window.geometry("800x600")
            analysis_window.transient(self.root)
            analysis_window.grab_set()
            
            # Create notebook for tabs
            notebook = ttk.Notebook(analysis_window)
            notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Histogram Analysis Tab
            hist_frame = ttk.Frame(notebook)
            notebook.add(hist_frame, text="Histograms")
            
            fig_hist, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))
            fig_hist.suptitle("Pixel Value Distribution")
            
            # Encrypted histogram
            ax1.hist(self.encrypted_img.flatten(), bins=256, range=(0, 255), alpha=0.7, color='red')
            ax1.set_title("Encrypted Image")
            ax1.set_xlabel("Pixel Value")
            ax1.set_ylabel("Frequency")
            
            # Decrypted histogram
            ax2.hist(self.decrypted_img.flatten(), bins=256, range=(0, 255), alpha=0.7, color='green')
            ax2.set_title("Decrypted Image")
            ax2.set_xlabel("Pixel Value")
            ax2.set_ylabel("Frequency")
            
            plt.tight_layout()
            
            hist_canvas = FigureCanvasTkAgg(fig_hist, hist_frame)
            hist_canvas.draw()
            hist_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
            # Security Metrics Tab
            metrics_frame = ttk.Frame(notebook)
            notebook.add(metrics_frame, text="Decryption Metrics")
            
            # Calculate metrics
            encrypted_entropy = self.calculate_entropy(self.encrypted_img)
            decrypted_entropy = self.calculate_entropy(self.decrypted_img)
            
            encrypted_corr = self.calculate_correlation(self.encrypted_img)
            decrypted_corr = self.calculate_correlation(self.decrypted_img)
            
            # Display metrics
            metrics_text = f"""
            Decryption Performance:
            - Decryption Time: {self.decryption_time:.3f} seconds
            - Decryption Rounds: {self.dec_rounds.get()}
            
            Entropy Analysis:
            - Encrypted Image: {encrypted_entropy:.6f}
            - Decrypted Image: {decrypted_entropy:.6f}
            
            Correlation Coefficient:
            - Encrypted Image: {encrypted_corr:.6f}
            - Decrypted Image: {decrypted_corr:.6f}
            
            Image Quality:
            - Decryption Status: Successful
            - Entropy Change: {decrypted_entropy - encrypted_entropy:+.6f}
            - Correlation Change: {decrypted_corr - encrypted_corr:+.6f}
            """
            
            metrics_label = tk.Text(metrics_frame, wrap=tk.WORD, font=('Arial', 10))
            metrics_label.insert(tk.END, metrics_text)
            metrics_label.config(state=tk.DISABLED)
            metrics_label.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            self.update_status("Decryption analysis completed")
            
        except Exception as e:
            messagebox.showerror("Error", f"Decryption analysis failed: {str(e)}")
            self.update_status("Decryption analysis failed")
    
    def calculate_correlation(self, img):
        """Calculate correlation coefficient between adjacent pixels"""
        h, w = img.shape
        
        # Flatten the image and create shifted versions
        flat_img = img.flatten()
        
        # Horizontal correlation
        if len(flat_img) > 1:
            corr = np.corrcoef(flat_img[:-1], flat_img[1:])[0, 1]
            return corr if not np.isnan(corr) else 1.0
        return 1.0

if __name__ == "__main__":
    root = tk.Tk()
    app = ImageDecryptionApp(root)
    root.mainloop()
